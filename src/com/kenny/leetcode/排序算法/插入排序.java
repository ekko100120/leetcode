package com.kenny.leetcode.排序算法;

public class 插入排序 {

    //插入排序

    /*原理：
    每次执行，把后面的数插入到前面已经排序好的数组中，直到最后一个完成。

    详细步骤：
    利用插入法对无序数组排序时，我们其实是将数组R划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，可称无序区）。
    插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，
    使R[1．．i]变为新的有序区。因为这种方法每次使有序区增加1个记录，通常称增量法。
    插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。
    为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。*/


    /*插入排序分析：
            1、时间复杂度，由于仍然需要两层循环，插入排序的时间复杂度仍然为O(n*n)。
            2、比较次数：在第一轮排序中，插入排序最多比较一次；在第二轮排序中插入排序最多比较二次；
    以此类推，最后一轮排序时，最多比较N-1次，因此插入排序的最多比较次数为1+2+…+N-1=N*(N-1)/2。
    尽管如此，实际上插入排序很少会真的比较这么多次，因为一旦发现左侧有比目标元素小的元素，比较就停止了，因此，插入排序平均比较次数为N*(N-1)/4。
            3、移动次数：插入排序的移动次数与比较次数几乎一致，但移动的速度要比交换的速度快得多。
    综上，插入排序的速度约比冒泡排序快一倍（比较次数少一倍），比选择排序还要快一些，对于基本有序的数据，插入排序的速度会很快，是简单排序中效率最高的排序算法。
    */
    public static int[] InsertSort(int[] arr){
        int i,j;
        int length = arr.length;
        int target;

        for (i = 1;  i<length ; i++) {

            j=i;
            target=arr[i];
            while (j>0 && target<arr[j-1]){
                arr[j] = arr[j-1];
                j--;
            }
            arr[j] =target;

        }
        return arr;
    }


    public static int[] InsertSort1(int[] arr){

        int i, j;
        int length = arr.length;
        int target;
        for (i = 1;  i<length ; i++) {

            target =arr[i];
            j=i;
            while (j>0&& arr[j-1]>arr[j]){
                arr[j] =arr[j-1];
            }
            arr[j] =target;

        }
        return arr;

    }
}
